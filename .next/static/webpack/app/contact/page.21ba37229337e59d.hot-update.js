"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/contact/page",{

/***/ "(app-pages-browser)/./lib/hooks/use-keyboard-navigation.ts":
/*!**********************************************!*\
  !*** ./lib/hooks/use-keyboard-navigation.ts ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFocusRestore: function() { return /* binding */ useFocusRestore; },\n/* harmony export */   useKeyboardNavigation: function() { return /* binding */ useKeyboardNavigation; },\n/* harmony export */   useSkipToContent: function() { return /* binding */ useSkipToContent; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ useKeyboardNavigation,useSkipToContent,useFocusRestore auto */ \n/**\n * Hook for managing keyboard navigation and focus trapping\n */ function useKeyboardNavigation(containerRef) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { onEscape, onEnter, trapFocus = false, autoFocus = false } = options;\n    // Get all focusable elements\n    const getFocusableElements = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!containerRef.current) return [];\n        const selector = [\n            \"a[href]\",\n            \"button:not([disabled])\",\n            \"textarea:not([disabled])\",\n            \"input:not([disabled])\",\n            \"select:not([disabled])\",\n            '[tabindex]:not([tabindex=\"-1\"])'\n        ].join(\", \");\n        return Array.from(containerRef.current.querySelectorAll(selector));\n    }, [\n        containerRef\n    ]);\n    // Handle keyboard events\n    const handleKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        // Escape key\n        if (event.key === \"Escape\" && onEscape) {\n            event.preventDefault();\n            onEscape();\n            return;\n        }\n        // Enter key\n        if (event.key === \"Enter\" && onEnter) {\n            event.preventDefault();\n            onEnter();\n            return;\n        }\n        // Tab key for focus trapping\n        if (trapFocus && event.key === \"Tab\") {\n            const focusableElements = getFocusableElements();\n            if (focusableElements.length === 0) return;\n            const firstElement = focusableElements[0];\n            const lastElement = focusableElements[focusableElements.length - 1];\n            if (event.shiftKey) {\n                // Shift + Tab\n                if (document.activeElement === firstElement) {\n                    event.preventDefault();\n                    lastElement.focus();\n                }\n            } else {\n                // Tab\n                if (document.activeElement === lastElement) {\n                    event.preventDefault();\n                    firstElement.focus();\n                }\n            }\n        }\n    }, [\n        onEscape,\n        onEnter,\n        trapFocus,\n        getFocusableElements\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const container = containerRef.current;\n        if (!container) return;\n        // Auto focus first element\n        if (autoFocus) {\n            const focusableElements = getFocusableElements();\n            if (focusableElements.length > 0) {\n                focusableElements[0].focus();\n            }\n        }\n        // Add event listener\n        container.addEventListener(\"keydown\", handleKeyDown);\n        return ()=>{\n            container.removeEventListener(\"keydown\", handleKeyDown);\n        };\n    }, [\n        containerRef,\n        autoFocus,\n        handleKeyDown,\n        getFocusableElements\n    ]);\n    return {\n        getFocusableElements\n    };\n}\n/**\n * Hook for skip to main content functionality\n */ function useSkipToContent() {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const handleKeyDown = (event)=>{\n            // Alt + S to skip to main content\n            if (event.altKey && event.key === \"s\") {\n                event.preventDefault();\n                const mainContent = document.querySelector(\"main\");\n                if (mainContent) {\n                    mainContent.setAttribute(\"tabindex\", \"-1\");\n                    mainContent.focus();\n                    mainContent.addEventListener(\"blur\", ()=>{\n                        mainContent.removeAttribute(\"tabindex\");\n                    }, {\n                        once: true\n                    });\n                }\n            }\n        };\n        window.addEventListener(\"keydown\", handleKeyDown);\n        return ()=>window.removeEventListener(\"keydown\", handleKeyDown);\n    }, []);\n}\n/**\n * Hook for managing focus restoration\n */ function useFocusRestore(isOpen) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isOpen) return;\n        const previouslyFocused = document.activeElement;\n        return ()=>{\n            // Restore focus when component unmounts\n            if (previouslyFocused && previouslyFocused.focus) {\n                previouslyFocused.focus();\n            }\n        };\n    }, [\n        isOpen\n    ]);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9ob29rcy91c2Uta2V5Ym9hcmQtbmF2aWdhdGlvbi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs0R0FFOEQ7QUFFOUQ7O0NBRUMsR0FDTSxTQUFTRSxzQkFDZEMsWUFBMEI7UUFDMUJDLFVBQUFBLGlFQUtJLENBQUM7SUFFTCxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxZQUFZLEtBQUssRUFBRUMsWUFBWSxLQUFLLEVBQUUsR0FBR0o7SUFFcEUsNkJBQTZCO0lBQzdCLE1BQU1LLHVCQUF1QlIsa0RBQVdBLENBQUM7UUFDdkMsSUFBSSxDQUFDRSxhQUFhTyxPQUFPLEVBQUUsT0FBTyxFQUFFO1FBRXBDLE1BQU1DLFdBQVc7WUFDZjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDRCxDQUFDQyxJQUFJLENBQUM7UUFFUCxPQUFPQyxNQUFNQyxJQUFJLENBQUNYLGFBQWFPLE9BQU8sQ0FBQ0ssZ0JBQWdCLENBQWNKO0lBQ3ZFLEdBQUc7UUFBQ1I7S0FBYTtJQUVqQix5QkFBeUI7SUFDekIsTUFBTWEsZ0JBQWdCZixrREFBV0EsQ0FDL0IsQ0FBQ2dCO1FBQ0MsYUFBYTtRQUNiLElBQUlBLE1BQU1DLEdBQUcsS0FBSyxZQUFZYixVQUFVO1lBQ3RDWSxNQUFNRSxjQUFjO1lBQ3BCZDtZQUNBO1FBQ0Y7UUFFQSxZQUFZO1FBQ1osSUFBSVksTUFBTUMsR0FBRyxLQUFLLFdBQVdaLFNBQVM7WUFDcENXLE1BQU1FLGNBQWM7WUFDcEJiO1lBQ0E7UUFDRjtRQUVBLDZCQUE2QjtRQUM3QixJQUFJQyxhQUFhVSxNQUFNQyxHQUFHLEtBQUssT0FBTztZQUNwQyxNQUFNRSxvQkFBb0JYO1lBQzFCLElBQUlXLGtCQUFrQkMsTUFBTSxLQUFLLEdBQUc7WUFFcEMsTUFBTUMsZUFBZUYsaUJBQWlCLENBQUMsRUFBRTtZQUN6QyxNQUFNRyxjQUFjSCxpQkFBaUIsQ0FBQ0Esa0JBQWtCQyxNQUFNLEdBQUcsRUFBRTtZQUVuRSxJQUFJSixNQUFNTyxRQUFRLEVBQUU7Z0JBQ2xCLGNBQWM7Z0JBQ2QsSUFBSUMsU0FBU0MsYUFBYSxLQUFLSixjQUFjO29CQUMzQ0wsTUFBTUUsY0FBYztvQkFDcEJJLFlBQVlJLEtBQUs7Z0JBQ25CO1lBQ0YsT0FBTztnQkFDTCxNQUFNO2dCQUNOLElBQUlGLFNBQVNDLGFBQWEsS0FBS0gsYUFBYTtvQkFDMUNOLE1BQU1FLGNBQWM7b0JBQ3BCRyxhQUFhSyxLQUFLO2dCQUNwQjtZQUNGO1FBQ0Y7SUFDRixHQUNBO1FBQUN0QjtRQUFVQztRQUFTQztRQUFXRTtLQUFxQjtJQUd0RFQsZ0RBQVNBLENBQUM7UUFDUixNQUFNNEIsWUFBWXpCLGFBQWFPLE9BQU87UUFDdEMsSUFBSSxDQUFDa0IsV0FBVztRQUVoQiwyQkFBMkI7UUFDM0IsSUFBSXBCLFdBQVc7WUFDYixNQUFNWSxvQkFBb0JYO1lBQzFCLElBQUlXLGtCQUFrQkMsTUFBTSxHQUFHLEdBQUc7Z0JBQ2hDRCxpQkFBaUIsQ0FBQyxFQUFFLENBQUNPLEtBQUs7WUFDNUI7UUFDRjtRQUVBLHFCQUFxQjtRQUNyQkMsVUFBVUMsZ0JBQWdCLENBQUMsV0FBV2I7UUFFdEMsT0FBTztZQUNMWSxVQUFVRSxtQkFBbUIsQ0FBQyxXQUFXZDtRQUMzQztJQUNGLEdBQUc7UUFBQ2I7UUFBY0s7UUFBV1E7UUFBZVA7S0FBcUI7SUFFakUsT0FBTztRQUFFQTtJQUFxQjtBQUNoQztBQUVBOztDQUVDLEdBQ00sU0FBU3NCO0lBQ2QvQixnREFBU0EsQ0FBQztRQUNSLE1BQU1nQixnQkFBZ0IsQ0FBQ0M7WUFDckIsa0NBQWtDO1lBQ2xDLElBQUlBLE1BQU1lLE1BQU0sSUFBSWYsTUFBTUMsR0FBRyxLQUFLLEtBQUs7Z0JBQ3JDRCxNQUFNRSxjQUFjO2dCQUNwQixNQUFNYyxjQUFjUixTQUFTUyxhQUFhLENBQUM7Z0JBQzNDLElBQUlELGFBQWE7b0JBQ2ZBLFlBQVlFLFlBQVksQ0FBQyxZQUFZO29CQUNyQ0YsWUFBWU4sS0FBSztvQkFDakJNLFlBQVlKLGdCQUFnQixDQUMxQixRQUNBO3dCQUNFSSxZQUFZRyxlQUFlLENBQUM7b0JBQzlCLEdBQ0E7d0JBQUVDLE1BQU07b0JBQUs7Z0JBRWpCO1lBQ0Y7UUFDRjtRQUVBQyxPQUFPVCxnQkFBZ0IsQ0FBQyxXQUFXYjtRQUNuQyxPQUFPLElBQU1zQixPQUFPUixtQkFBbUIsQ0FBQyxXQUFXZDtJQUNyRCxHQUFHLEVBQUU7QUFDUDtBQUVBOztDQUVDLEdBQ00sU0FBU3VCLGdCQUFnQkMsTUFBZTtJQUM3Q3hDLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxDQUFDd0MsUUFBUTtRQUViLE1BQU1DLG9CQUFvQmhCLFNBQVNDLGFBQWE7UUFFaEQsT0FBTztZQUNMLHdDQUF3QztZQUN4QyxJQUFJZSxxQkFBcUJBLGtCQUFrQmQsS0FBSyxFQUFFO2dCQUNoRGMsa0JBQWtCZCxLQUFLO1lBQ3pCO1FBQ0Y7SUFDRixHQUFHO1FBQUNhO0tBQU87QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvaG9va3MvdXNlLWtleWJvYXJkLW5hdmlnYXRpb24udHM/OGEwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrLCB0eXBlIFJlZk9iamVjdCB9IGZyb20gXCJyZWFjdFwiXG5cbi8qKlxuICogSG9vayBmb3IgbWFuYWdpbmcga2V5Ym9hcmQgbmF2aWdhdGlvbiBhbmQgZm9jdXMgdHJhcHBpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUtleWJvYXJkTmF2aWdhdGlvbjxUIGV4dGVuZHMgSFRNTEVsZW1lbnQgPSBIVE1MRWxlbWVudD4oXG4gIGNvbnRhaW5lclJlZjogUmVmT2JqZWN0PFQ+LFxuICBvcHRpb25zOiB7XG4gICAgb25Fc2NhcGU/OiAoKSA9PiB2b2lkXG4gICAgb25FbnRlcj86ICgpID0+IHZvaWRcbiAgICB0cmFwRm9jdXM/OiBib29sZWFuXG4gICAgYXV0b0ZvY3VzPzogYm9vbGVhblxuICB9ID0ge30sXG4pIHtcbiAgY29uc3QgeyBvbkVzY2FwZSwgb25FbnRlciwgdHJhcEZvY3VzID0gZmFsc2UsIGF1dG9Gb2N1cyA9IGZhbHNlIH0gPSBvcHRpb25zXG5cbiAgLy8gR2V0IGFsbCBmb2N1c2FibGUgZWxlbWVudHNcbiAgY29uc3QgZ2V0Rm9jdXNhYmxlRWxlbWVudHMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFjb250YWluZXJSZWYuY3VycmVudCkgcmV0dXJuIFtdXG5cbiAgICBjb25zdCBzZWxlY3RvciA9IFtcbiAgICAgIFwiYVtocmVmXVwiLFxuICAgICAgXCJidXR0b246bm90KFtkaXNhYmxlZF0pXCIsXG4gICAgICBcInRleHRhcmVhOm5vdChbZGlzYWJsZWRdKVwiLFxuICAgICAgXCJpbnB1dDpub3QoW2Rpc2FibGVkXSlcIixcbiAgICAgIFwic2VsZWN0Om5vdChbZGlzYWJsZWRdKVwiLFxuICAgICAgJ1t0YWJpbmRleF06bm90KFt0YWJpbmRleD1cIi0xXCJdKScsXG4gICAgXS5qb2luKFwiLCBcIilcblxuICAgIHJldHVybiBBcnJheS5mcm9tKGNvbnRhaW5lclJlZi5jdXJyZW50LnF1ZXJ5U2VsZWN0b3JBbGw8SFRNTEVsZW1lbnQ+KHNlbGVjdG9yKSlcbiAgfSwgW2NvbnRhaW5lclJlZl0pXG5cbiAgLy8gSGFuZGxlIGtleWJvYXJkIGV2ZW50c1xuICBjb25zdCBoYW5kbGVLZXlEb3duID0gdXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAvLyBFc2NhcGUga2V5XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiICYmIG9uRXNjYXBlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgb25Fc2NhcGUoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gRW50ZXIga2V5XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgJiYgb25FbnRlcikge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIG9uRW50ZXIoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gVGFiIGtleSBmb3IgZm9jdXMgdHJhcHBpbmdcbiAgICAgIGlmICh0cmFwRm9jdXMgJiYgZXZlbnQua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzYWJsZUVsZW1lbnRzID0gZ2V0Rm9jdXNhYmxlRWxlbWVudHMoKVxuICAgICAgICBpZiAoZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAgICAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSBmb2N1c2FibGVFbGVtZW50c1swXVxuICAgICAgICBjb25zdCBsYXN0RWxlbWVudCA9IGZvY3VzYWJsZUVsZW1lbnRzW2ZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCAtIDFdXG5cbiAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgLy8gU2hpZnQgKyBUYWJcbiAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZmlyc3RFbGVtZW50KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICBsYXN0RWxlbWVudC5mb2N1cygpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRhYlxuICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBsYXN0RWxlbWVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgZmlyc3RFbGVtZW50LmZvY3VzKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFtvbkVzY2FwZSwgb25FbnRlciwgdHJhcEZvY3VzLCBnZXRGb2N1c2FibGVFbGVtZW50c10sXG4gIClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50XG4gICAgaWYgKCFjb250YWluZXIpIHJldHVyblxuXG4gICAgLy8gQXV0byBmb2N1cyBmaXJzdCBlbGVtZW50XG4gICAgaWYgKGF1dG9Gb2N1cykge1xuICAgICAgY29uc3QgZm9jdXNhYmxlRWxlbWVudHMgPSBnZXRGb2N1c2FibGVFbGVtZW50cygpXG4gICAgICBpZiAoZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb2N1c2FibGVFbGVtZW50c1swXS5mb2N1cygpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24pXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24pXG4gICAgfVxuICB9LCBbY29udGFpbmVyUmVmLCBhdXRvRm9jdXMsIGhhbmRsZUtleURvd24sIGdldEZvY3VzYWJsZUVsZW1lbnRzXSlcblxuICByZXR1cm4geyBnZXRGb2N1c2FibGVFbGVtZW50cyB9XG59XG5cbi8qKlxuICogSG9vayBmb3Igc2tpcCB0byBtYWluIGNvbnRlbnQgZnVuY3Rpb25hbGl0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU2tpcFRvQ29udGVudCgpIHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAvLyBBbHQgKyBTIHRvIHNraXAgdG8gbWFpbiBjb250ZW50XG4gICAgICBpZiAoZXZlbnQuYWx0S2V5ICYmIGV2ZW50LmtleSA9PT0gXCJzXCIpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICBjb25zdCBtYWluQ29udGVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJtYWluXCIpXG4gICAgICAgIGlmIChtYWluQ29udGVudCkge1xuICAgICAgICAgIG1haW5Db250ZW50LnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiLTFcIilcbiAgICAgICAgICBtYWluQ29udGVudC5mb2N1cygpXG4gICAgICAgICAgbWFpbkNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwiYmx1clwiLFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICBtYWluQ29udGVudC5yZW1vdmVBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKVxuICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlS2V5RG93bilcbiAgfSwgW10pXG59XG5cbi8qKlxuICogSG9vayBmb3IgbWFuYWdpbmcgZm9jdXMgcmVzdG9yYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvY3VzUmVzdG9yZShpc09wZW46IGJvb2xlYW4pIHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzT3BlbikgcmV0dXJuXG5cbiAgICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnRcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBSZXN0b3JlIGZvY3VzIHdoZW4gY29tcG9uZW50IHVubW91bnRzXG4gICAgICBpZiAocHJldmlvdXNseUZvY3VzZWQgJiYgcHJldmlvdXNseUZvY3VzZWQuZm9jdXMpIHtcbiAgICAgICAgcHJldmlvdXNseUZvY3VzZWQuZm9jdXMoKVxuICAgICAgfVxuICAgIH1cbiAgfSwgW2lzT3Blbl0pXG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VLZXlib2FyZE5hdmlnYXRpb24iLCJjb250YWluZXJSZWYiLCJvcHRpb25zIiwib25Fc2NhcGUiLCJvbkVudGVyIiwidHJhcEZvY3VzIiwiYXV0b0ZvY3VzIiwiZ2V0Rm9jdXNhYmxlRWxlbWVudHMiLCJjdXJyZW50Iiwic2VsZWN0b3IiLCJqb2luIiwiQXJyYXkiLCJmcm9tIiwicXVlcnlTZWxlY3RvckFsbCIsImhhbmRsZUtleURvd24iLCJldmVudCIsImtleSIsInByZXZlbnREZWZhdWx0IiwiZm9jdXNhYmxlRWxlbWVudHMiLCJsZW5ndGgiLCJmaXJzdEVsZW1lbnQiLCJsYXN0RWxlbWVudCIsInNoaWZ0S2V5IiwiZG9jdW1lbnQiLCJhY3RpdmVFbGVtZW50IiwiZm9jdXMiLCJjb250YWluZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVzZVNraXBUb0NvbnRlbnQiLCJhbHRLZXkiLCJtYWluQ29udGVudCIsInF1ZXJ5U2VsZWN0b3IiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvbmNlIiwid2luZG93IiwidXNlRm9jdXNSZXN0b3JlIiwiaXNPcGVuIiwicHJldmlvdXNseUZvY3VzZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/hooks/use-keyboard-navigation.ts\n"));

/***/ })

});